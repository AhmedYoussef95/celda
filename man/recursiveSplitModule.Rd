% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/recursiveSplit.R
\name{recursiveSplitModule}
\alias{recursiveSplitModule}
\title{Recursive module splitting}
\usage{
recursiveSplitModule(counts, initial.L = 10, max.L = 100, temp.K = 100,
  z.init = NULL, sample.label = NULL, alpha = 1, beta = 1, delta = 1,
  gamma = 1, min.feature = 3, reorder = TRUE, perplexity = TRUE,
  seed = 12345, verbose = TRUE, logfile = NULL)
}
\arguments{
\item{counts}{Integer matrix. Rows represent features and columns represent cells.}

\item{initial.L}{Integer. Minimum number of modules to try.}

\item{max.L}{Integer. Maximum number of modules to try.}

\item{temp.K}{Integer. Number of temporary cell populations to identify and use in module splitting. Only used if `z.init=NULL` Collapsing cells to a relatively smaller number of cell popluations will increase the speed of module clustering and tend to produce better modules. This number should be larger than the number of true cell populations expected in the dataset. Default 100.}

\item{z.init}{Integer vector. Collapse cells to cell populations based on labels in `z.init` and then perform module splitting. If NULL, no collapasing will be performed unless `temp.K` is specified. Default NULL.}

\item{sample.label}{Vector or factor. Denotes the sample label for each cell (column) in the count matrix. Only used if `z.init` is set.}

\item{alpha}{Numeric. Concentration parameter for Theta. Adds a pseudocount to each cell population in each sample. Only used if `z.init` is set. Default 1.}

\item{beta}{Numeric. Concentration parameter for Phi. Adds a pseudocount to each feature module in each cell. Default 1.}

\item{delta}{Numeric. Concentration parameter for Psi. Adds a pseudocount to each feature in each module. Default 1.}

\item{gamma}{Numeric. Concentration parameter for Eta. Adds a pseudocount to the number of features in each module. Default 1.}

\item{min.feature}{Integer. Only attempt to split modules with at least this many features.}

\item{reorder}{Logical. Whether to reorder modules using hierarchical clustering after each model has been created. If FALSE, module numbers will correspond to the split which created the module (i.e. 'L15' was created at split 15, 'L16' was created at split 16, etc.). Default TRUE.}

\item{perplexity}{Logical. Whether to calculate perplexity for each model. If FALSE, then perplexity can be calculated later with `resamplePerplexity()`. Default TRUE.}

\item{seed}{Integer. Passed to `set.seed()`. Default 12345. If NULL, no calls to `set.seed()` are made.}

\item{verbose}{Logical. Whether to print log messages. Default TRUE.}

\item{logfile}{Character. Messages will be redirected to a file named `logfile`. If NULL, messages will be printed to stdout.  Default NULL.}
}
\value{
Object of class `celda_list`, which contains results for all model parameter combinations and summaries of the run parameters. The models in the list will be of class `celda_G` if `z.init=NULL` or `celda_CG` if `z.init` is set.
}
\description{
Uses the `celda_G` model to cluster features into modules for a range of possible L's. The module labels of the previous "L-1" model are used as the initial values in the current model with L modules. The best split of an existing module is found to create the L-th module. This procedure is much faster than randomly initializing each model with a different L.
}
\examples{
## Create models that range from L=3 to L=20 by recursively splitting modules into two
module.split = recursiveSplitModule(celda.CG.sim$counts, initial.L = 3, max.L=20)

## Example results with perplexity
plotGridSearchPerplexity(module.split)

## Select model for downstream analysis
celda.mod = subsetCeldaList(module.split, list(L=10))
}
\seealso{
`recursiveSplitCell()` for recursive splitting of cell populations.
}
